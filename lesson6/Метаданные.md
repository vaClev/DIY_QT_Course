В QT есть возможность получать информацию о сигналах и слотах в Runtime

Что такое QMetaMethod?
```
*Класс для интроспекции методов Qt (сигналов, слотов, обычных методов)
*Часть мета-объектной системы Qt
*Позволяет получать информацию о методах во время выполнения
```
Основные возможности
1. Получение информации о методах
```cpp
const QMetaObject* meta = obj->metaObject(); //obj наследник QObject
QMetaMethod method = meta->method(index);

// Основные свойства:
method.methodSignature();  // "valueChanged(int)"
method.methodType();       // Signal, Slot, Method, Constructor
method.returnType();       // Тип возвращаемого значения
method.parameterCount();   // Количество параметров
method.parameterTypes();   // Список типов параметров
```

2. Типы методов
```cpp
QMetaMethod::MethodType type = method.methodType();
// Возможные значения:
// - QMetaMethod::Signal
// - QMetaMethod::Slot  
// - QMetaMethod::Method
// - QMetaMethod::Constructor
```

3. Поиск методов
```cpp
// Поиск по индексу
int slotIndex = metaObject->indexOfSlot("mySlot(int)");
int signalIndex = metaObject->indexOfSignal("mySignal(QString)");
int methodIndex = metaObject->indexOfMethod("myMethod()");

// Получение метода
if (slotIndex != -1) {
    QMetaMethod method = metaObject->method(slotIndex);
}
```
4. Динамический вызов методов
```cpp
// Синхронный вызов
method.invoke(obj, 
    Qt::DirectConnection,
    Q_ARG(int, 42),
    Q_ARG(QString, "hello")
);

// Асинхронный вызов  
method.invoke(obj,
    Qt::QueuedConnection,
    Q_ARG(double, 3.14)
);
```

Ограничения
```
Работает только с Q_OBJECT классами
Не видит private slots через indexOfSlot()
Требует точного совпадения сигнатур
Нет доступа к реализации методов
```